package protocol_stack

import (
	"fmt"
	"testing"
)

func TestParseDLT645Frame(t *testing.T) {
	// 示例解析
	//FE FE 68 72 00 32 09 17 20 68 91 08 33 33 34 33 B9 34 33 33 6D 16
	//rawFrame := []byte{0xFE, 0xFE, 0xFE, 0xFE, 0x68, 0x72, 0x00, 0x32, 0x09, 0x17, 0x20, 0x68, 0x91, 0x08, 0x33, 0x33, 0x34, 0x33, 0xB9, 0x34, 0x33, 0x33, 0x6D, 0x16}
	//FE FE FE FE 68 00 00 00 00 00 00 68 11 04 33 33 33 33 B1 16
	//rawFrame := []byte{0xFE, 0xFE, 0xFE, 0xFE, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x11, 0x04, 0x33, 0x33, 0x33, 0x33, 0xB1, 0x16}
	//fe fe fe fe 68 00 00 00 00 00 00 68 91 06 33 34 34 35 4c 56 d9 16
	rawFrame := []byte{0xfe, 0xfe, 0xfe, 0xfe, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x91, 0x06, 0x33, 0x34, 0x34, 0x35, 0x4c, 0x56, 0xd9, 0x16}
	err1, i := ElectricityAnswer(rawFrame)
	//rawFrame := []byte{0x68, 0x01, 0x00, 0x00, 0x00, 0x00, 0x10, 0x68, 0x11, 0x04, 0x33, 0x33, 0x34, 0x35, 0xC5, 0x16}
	if err1 != nil {
		fmt.Printf("应答解析失败: %v\n", err1)
	}
	frame, err := ParseDLT645Frame(i)
	if err != nil {
		fmt.Printf("解析失败: %v\n", err)
		return
	}
	fmt.Printf("解析成功: %+v\n", frame)
	// 数据域去偏移
	decodedData := OffsetData(frame.Data, false)
	fmt.Printf("去偏移后的数据域: %X\n", decodedData)

	// 示例完整数据段：数据标识 + 数据值
	//dataSegment := []byte{0x02, 0x01, 0x00, 0x00, 0x12, 0x34} // DI 为 02-01-00-00，数据值为 0x3412

	// 调用解析函数
	dataType, value, phase, err := ParseDataSegment(decodedData)
	if err != nil {
		fmt.Printf("解析失败: %v\n", err)
		return
	}

	fmt.Printf("解析结果: 类型 = %s, 值 = %s, 相位 = %s\n", dataType, value, phase)

}

func TestBuildDLT645Frame(t *testing.T) {
	// 示例生成
	newFrame, err := BuildDLT645Frame("000000000010", 0x11, OffsetData([]byte{0x00, 0x00, 0x01, 0x02}, true))
	if err != nil {
		fmt.Printf("生成失败: %v\n", err)
		return
	}
	fmt.Printf("生成的新数据帧: %X\n", newFrame)
}
